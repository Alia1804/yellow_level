так я хочу объяснить, как я решала все эти задачи (ну мало ли). кст в моем профиле опубликованы мои проекты некоторые по питону, в основном там PyGame (ну мало ли вам интересно будет). и так


1 задача. в ней нам по условию нужно было заменить число суммой его квадратов, и если число становится равным 1, вернуть true, если число уже находится в множестве, вернуть false, добавить число в множество и повторить все эти этапы, пока число не будет равным 1 или не будет обнаружен цикл. дальнешие комментарии есть в самом коде.


2 задача. этот алгоритм позволяет отсортировать массив внутри себя, используя три указателя для отслеживания границ между различными цветами. проще будет посмотреть) там есть три переменных 
low: указатель для отслеживания границы между нулями и единицами.
mid: указатель для отслеживания текущего элемента.
high: указатель для отслеживания границы между единицами и двойками. (я просто уже делала похожую задачу и у этого алгоритма в питоне даже есть свое название, не помню какое)

если текущий элемент равен 0,  то меняем его местами с элементом на позиции low и увеличиваем оба указателя low и mid.
если текущий элемент равен 1, просто увеличиваем указатель mid.
если текущий элемент равен 2, меняем его местами с элементом на позиции high и уменьшаем указатель high.

и просто дальше продолжаем этот процесс, пока указатель mid не станет больше или равен указателю high. все просто 



3 задача. у меня закончилась фанатзия или просто устала придумывать названия для функций, поэтому просто будет something). и так мы берем сортируем интервалы с ключом lambda, чтобы отсортировать интервалы по начальным точкам. проходим по каждому интревалу в отсортированном масиве.
если массив пуст или текущий интервал не пересекается с последним добавленным интервалом , добавляем текущий интервал в массив.
если текущий интервал пересекается с последним добавленным интервалом, объединяем их, обновляя конечную точку последнего интервала в на максимальную из конечных точек текущего интервала и последнего интервала. надеюсь понятно объяснила, а то почти 12 ночи язык заплетается. 



4 задача. чтобы было проще, объясню значечния переменных. 
char_index_map - это типа будто словарь для хранения последних позиций символов.
left - это как бы левый указатель, инициализируется нулём.
max_length - это надеюсь понятно объяснила максимальная длина подстроки, инициализируется нулём.

я создала цикл for для перемещения правого указателя по строке.
если текущий символ уже находится в char_index и его индекс больше или равен left, перемещаем left на одну позицию вправо от последней позиции этого символа.
обновляем позицию текущего символа.
обновляем max_length как максимум между текущим max_length и длиной текущего окна (right - left + 1).

возвращаем max_length, который содержит длину самой длинной подстроки без повторяющихся символов.




5 задача. класс определяет узел связного списка. этот самый узел имеет два атрибута значение узла и ссылку на след узед. функция принимает типа две головы связных списков headA и headB и возвращает узел, с которого начинается их пересечение или None если пересечения нет.

если pA не равен None, перемещаем pA на следующий узел (pA = pA.next). если pA равен None то перемещаем pA на голову второго списка (pA = headB).
по типу этого же если pB не равен None, перемещаем pB на следующий узел (pB = pB.next), а если pB равен None перемещаем pB на голову первого списка (pB = headA).

Когда pA и pB указывают на один и тот же узел, это означает, что мы нашли пересечение и мы должгы вернуть pA (или pB, так как они указывают на один и тот же узел).
